# Правила процедурной разработки

## Метаправило

**Эти правила — процедурная спецификация того, «что именно делать руками» при разработке.**

Каждое правило операционально: его можно выполнить, проверить, автоматизировать.

---

## 1. Атомарность коммитов

### Правило 1.1: Один MES = Один коммит

```
∀ commit: commit содержит результат ровно одного MES
```

**Почему**: Атомарность позволяет откатывать изменения без потери контекста.

**Как проверить**: Коммит описывается одним действием в прошедшем времени.

**Примеры:**
- ✅ `"Создан компонент PhilosophicalFoundation"`
- ✅ `"Добавлена секция с алгоритмом декомпозиции"`
- ❌ `"Поработал над сайтом"` (не атомарно)
- ❌ `"Исправления и улучшения"` (не конкретно)

### Правило 1.2: Коммит только после verification

```
commit(MES) ⟺ postconditions(MES) verified
```

**Процедура коммита:**

```
1. Выполнить MES
2. Проверить postconditions:
   - Код компилируется
   - Нет ошибок в консоли
   - Визуально корректен (если UI)
3. Запустить линтер (if applicable)
4. git add . && git commit -m "..."
```

---

## 2. Декомпозиция кода

### Правило 2.1: Файл < 200 строк

```
∀ file: lines(file) < 200  ∨  decompose(file)
```

**Почему**: Большие файлы = сложность → нарушение атомарности.

**Как**: Выносить логику в отдельные компоненты/утилиты.

### Правило 2.2: Функция < 50 строк

```
∀ function: lines(function) < 50  ∨  decompose(function)
```

**Исключения**: Генерируемый код, конфигурация.

### Правило 2.3: Один уровень абстракции

```
∀ function: all statements at same abstraction level
```

**Примеры:**

❌ **Плохо**: Смешение уровней
```typescript
function processUser(user: User) {
  const db = connectDB() // низкий уровень
  validateEmail(user.email) // средний уровень
  sendWelcomeEmail(user) // высокий уровень
}
```

✅ **Хорошо**: Единый уровень
```typescript
function processUser(user: User) {
  validateUser(user)
  saveUser(user)
  notifyUser(user)
}
```

---

## 3. Зависимости

### Правило 3.1: Минимум внешних зависимостей

```
∀ dependency: necessary(dependency)  ∨  remove(dependency)
```

**Перед установкой библиотеки:**

1. Можно ли написать сами за 30 минут?
2. Поддерживается ли библиотека?
3. Сколько transitive dependencies?

**Если да / да / < 5** → установить

### Правило 3.2: Граф зависимостей ациклический

```
∀ modules A, B: (A → B) ⟹ ¬(B → A)
```

**Как проверить**: `madge --circular src/`

**Решение циклов**: Выделить общую зависимость в отдельный модуль.

---

## 4. Именование

### Правило 4.1: Имя = действие или сущность

```
∀ name: describes_action(name)  ∨  describes_entity(name)
```

**Функции**: глаголы
- `fetchUser()`, `calculateTotal()`, `renderGraph()`

**Компоненты**: существительные
- `UserProfile`, `DependencyGraph`, `MathSection`

**Переменные**: существительные или прилагательные
- `userName`, `isLoading`, `totalCount`

### Правило 4.2: Нет сокращений

```
∀ name: ¬abbreviation(name)  ∨  universally_known(name)
```

**Исключения**: `id`, `url`, `api`, `html`, `css`

❌ `usrProf`, `calcTot`, `depGraph`
✅ `userProfile`, `calculateTotal`, `dependencyGraph`

### Правило 4.3: Булевы переменные начинаются с is/has/can

```
∀ bool_var: prefix(bool_var) ∈ {is, has, can, should, will}
```

✅ `isLoading`, `hasError`, `canSubmit`, `shouldRender`
❌ `loading`, `error`, `submit`, `render`

---

## 5. Структура проекта

### Правило 5.1: Плоская структура компонентов

```
components/
  ├─ Button.tsx
  ├─ Card.tsx
  ├─ Header.tsx
  └─ examples/
      ├─ TikTokProcedure.tsx
      └─ LispAnalogy.tsx
```

**Группировка**: только если > 5 связанных компонентов.

### Правило 5.2: Colocation контента

```
∀ component: data(component) близко к component
```

**Пример:**

```
components/
  └─ MathSection/
      ├─ MathSection.tsx
      ├─ formulas.ts (данные)
      └─ MathSection.test.tsx (тесты)
```

---

## 6. Стили

### Правило 6.1: Tailwind классы inline

```
∀ component: styles(component) = tailwind_classes
```

**Почему**: Colocation стилей с компонентами.

**Исключение**: Сложные анимации → отдельный CSS файл.

### Правило 6.2: Responsive-first

```
∀ layout: mobile_first(layout)
```

**Процедура:**

```
1. Сверстать для mobile (320px)
2. Добавить md: для tablet (768px)
3. Добавить lg: для desktop (1024px)
```

---

## 7. Тестирование

### Правило 7.1: Критические пути покрыты

```
∀ critical_path: ∃ test(critical_path)
```

**Критический путь**: То, что ломает UX при поломке.

**Примеры:**
- Рендеринг главной страницы
- Отображение графа зависимостей
- Навигация между секциями

### Правило 7.2: Тест = спецификация

```
∀ test: test описывает postcondition
```

**Пример:**

```typescript
describe('DependencyGraph', () => {
  it('should render all nodes from graph data', () => {
    const graph = { nodes: [...], edges: [...] }
    render(<DependencyGraph graph={graph} />)
    
    expect(screen.getAllByRole('treeitem')).toHaveLength(graph.nodes.length)
  })
})
```

---

## 8. Процесс разработки

### Правило 8.1: MES перед началом дня

```
∀ day: select_MES() перед началом работы
```

**Процедура утра:**

```
1. Открыть TODO list
2. Выбрать 1-3 MES на сегодня
3. Оценить duration
4. Начать с наивысшего приоритета
```

### Правило 8.2: Таймбоксинг MES

```
∀ MES: duration(MES) ≤ 2 часа
```

**Если MES > 2 часа**: декомпозировать дальше.

**Почему**: Длинные задачи = высокий риск застревания.

### Правило 8.3: Break после MES

```
∀ MES: after(complete(MES)) → break(10 минут)
```

**Процедура завершения MES:**

```
1. Проверить postconditions
2. Сделать коммит
3. Обновить TODO
4. 10 минут отдыха
5. Вернуться к следующему MES
```

---

## 9. Детекция проблем

### Правило 9.1: Застрял > 30 минут → декомпозировать

```
if time_on_task > 30 минут ∧ progress == 0:
  → decompose_further(current_MES)
```

**Сигналы застревания:**
- Не понятно, что делать дальше
- Код не компилируется > 15 минут
- Ищешь решение в интернете > 20 минут

**Действие:**

```
1. Остановиться
2. Записать, где застрял
3. Разбить задачу на 2-3 более мелких
4. Начать с самого простого
```

### Правило 9.2: Рефакторинг при повторении

```
if code_pattern повторяется ≥ 3 раз:
  → extract_to_function(pattern)
```

**Правило трёх**: Не рефакторить раньше времени.

---

## 10. Документация

### Правило 10.1: README для каждой директории

```
∀ directory: depth(directory) ≥ 2  ⟹  ∃ README.md
```

**Содержание README:**

```
# Название директории

## Назначение
Что содержится в этой папке.

## Структура
- file1.ts - описание
- file2.ts - описание

## Использование
Как использовать содержимое.
```

### Правило 10.2: Комментарии для неочевидного

```
∀ code: ¬obvious(code)  ⟹  add_comment(code)
```

**Что комментировать:**
- Почему, а не что (код показывает «что»)
- Неочевидные оптимизации
- Workarounds и временные решения

**Пример:**

```typescript
// Используем setTimeout вместо requestAnimationFrame
// т.к. RAF не работает в background вкладках (issue #123)
setTimeout(updateGraph, 16)
```

---

## 11. Перфоманс

### Правило 11.1: Измерять перед оптимизацией

```
∀ optimization: measure(current_performance) перед optimization
```

**Процедура оптимизации:**

```
1. Выявить bottleneck (Chrome DevTools)
2. Измерить текущую скорость
3. Оптимизировать
4. Измерить новую скорость
5. Если улучшение < 10% → откатить (не стоит сложности)
```

### Правило 11.2: Lazy loading для некритичного

```
∀ component: ¬critical(component)  ⟹  lazy_load(component)
```

**Критичное**: выше fold, нужно для первого рендера
**Некритичное**: ниже fold, графы, примеры

---

## 12. Безопасность

### Правило 12.1: Нет секретов в коде

```
∀ secret: ¬in_code(secret)  ∧  in_env(secret)
```

**Секреты**: API ключи, токены, пароли

**Использование:**

```
// ❌ Плохо
const API_KEY = "sk-abc123..."

// ✅ Хорошо
const API_KEY = process.env.NEXT_PUBLIC_API_KEY
```

### Правило 12.2: Валидация всех входов

```
∀ user_input: validate(user_input) перед use(user_input)
```

---

## 13. Git workflow

### Правило 13.1: Коммиты в main (для MVP)

```
∀ commit: target_branch(commit) = main
```

**Почему**: Solo dev, MVP, скорость важнее сложности.

**После MVP**: переход на feature branches.

### Правило 13.2: Префиксы коммитов

```
∀ commit_message: prefix(commit_message) ∈ {feat, fix, docs, refactor, test}
```

**Примеры:**

```
feat: Добавлен компонент DependencyGraph
fix: Исправлена ошибка рендера на mobile
docs: Обновлён README с инструкцией запуска
refactor: Вынесена логика в хук useGraphData
test: Добавлены тесты для MathSection
```

---

## 14. Метаправила

### Правило 14.1: Правила нарушаемы

```
∀ rule: ∃ context → break(rule) допустимо
```

**Но**: Нарушение должно быть осознанным и задокументированным.

### Правило 14.2: Правила эволюционируют

```
if rule не работает на практике:
  → update(rule)  ∨  remove(rule)
```

**Этот файл живой**: добавляем новые правила при обнаружении паттернов.

### Правило 14.3: Простота > перфекционизм

```
∀ decision: simple_solution > perfect_solution
```

**Почему**: Идеальный код, который не написан, не приносит ценности.

**MVP принцип**: Работает > красиво

---

## 15. Чеклист перед деплоем

```
[ ] Все MES в статусе completed
[ ] Нет console.log в prod коде
[ ] Линтер не выдаёт ошибок
[ ] Сайт работает локально на всех разрешениях
[ ] README обновлён с инструкциями запуска
[ ] ENV переменные настроены в Vercel
[ ] Lighthouse score > 80
```

---

## 16. Заключение

Эти правила — не догма, а **процедурная спецификация разработки**.

Каждое правило:
- Операционально (можно выполнить)
- Проверяемо (можно проверить)
- Измеримо (можно измерить соблюдение)

**Главное правило**: Если правило мешает прогрессу — пересмотри правило, а не прогресс.

---

**Следующий шаг**: Инициализация Next.js проекта (см. `docs/approach.md`, раздел 2.2)

