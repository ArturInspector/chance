# Проблема гомеостаза (Homeostasis Problem)
## Формулировка
**Основное утверждение:**

Внутренняя система (мозг, организм) стремится к равновесию и сопротивляется изменениям. Регулярное выполнение процедур и выход за рамки привычного встречает сопротивление.

```
∀ S (система), ∀ P (процедура):
  if P нарушает homeostasis(S) 
  then S → resistance(P)
```

## Теория гомеостаза

### 1. Определение равновесия
Система находится в состоянии равновесия:

```
homeostasis(S) = {
  energy_balance: input ≈ output
  stress_level: в пределах нормы
  routine: предсказуемые паттерны
}
```

### 2. Стоимость изменения
Любое новое действие A требует энергии сверх базовой:

```
cost(A) = base_cost(A) + adaptation_cost(A)
```

где:
- `base_cost(A)` — физическая/когнитивная энергия на выполнение
- `adaptation_cost(A)` — энергия на преодоление сопротивления системы

**Для новых действий:**

```
adaptation_cost(A_new) >> base_cost(A_new)
```

**Для привычных:**

```
adaptation_cost(A_routine) ≈ 0
```

### 3. Закон сохранения энергии

```
total_energy(S) = const (в краткосрочной перспективе)
```

Если агент начинает делать больше процедур:

```
Σ cost(Aᵢ) > total_energy(S) 
⟹ система включает защитные механизмы
```

## Защитные механизмы системы

### 1. Прокрастинация

```
procrastination(A) ⟺ 
  adaptation_cost(A) > available_energy(S)
```

Система откладывает действие, чтобы сохранить равновесие.

### 2. Саботаж выполнения
```
sabotage(A) = {
  "забыл",
  "не было времени",
  "не в настроении",
  "внезапно устал"
}
```

Рационализация отказа от действия.

### 3. Возвращение к привычному
```
∀ A_new: 
  если выполнять A_new регулярно
  то через время t система стремится:
    A_new → A_routine или A_new → ∅
```
Либо новое становится привычкой, либо отбрасывается.

## Математическая модель
### 1. Энергетический бюджет

```
Energy(t) = base_energy - Σ cost(Aᵢ, t) + recovery(t)
```

где:
- `base_energy` — базовый уровень энергии
- `recovery(t)` — восстановление (сон, отдых, питание)

### 2. Порог перегрузки

```
overload(S) ⟺ Energy(S) < threshold
```

При перегрузке:

```
probability(complete(A)) = exp(-adaptation_cost(A) / Energy(S))
```

Чем меньше энергии, тем ниже вероятность выполнения.

### 3. Адаптация и привыкание

После N повторений действия A:
```
adaptation_cost(A, N) = adaptation_cost(A, 0) × exp(-λN)
```

где λ — скорость адаптации.

**Типичные значения:**

```
N = 21 день → adaptation_cost снижается на ~50%
N = 66 дней → adaptation_cost → 0 (привычка сформирована)
```

## Практические следствия
### 1. Ограничение числа новых процедур

```
max_new_procedures = total_energy / avg(adaptation_cost)
```

**Правило:**

Не начинать более 2-3 новых процедур одновременно.

### 2. Последовательное внедрение

```
Strategy:
  1. Внедрить процедуру P₁
  2. Выполнять P₁ регулярно до привыкания (N > 21)
  3. Только потом добавить P₂
```

### 3. Учёт энергетического баланса

```
daily_plan(S):
  available = Energy(S)
  
  // Приоритет: привычные процедуры (низкая стоимость)
  for A in routine_actions:
    execute(A)
    available -= cost(A)
  
  // Затем: одна новая процедура (высокая стоимость)
  if available > threshold:
    A_new = select_new_action()
    execute(A_new)
```

## Проблема выхода за рамки

### 1. Зона комфорта

```
comfort_zone(S) = {A : adaptation_cost(A) ≈ 0}
```

Все действия, которые система делает без сопротивления.

### 2. Рост требует выхода

```
growth(S) ⟺ ∃ A ∉ comfort_zone(S): execute(A)
```

Но система сопротивляется росту:

```
resistance(growth) = max(adaptation_cost(A) for A in new_actions)
```

### 3. Парадокс роста

```
Хочу расти → нужно делать новое → система сопротивляется → не делаю → не расту
```

**Решение:**

Малые шаги, минимизирующие сопротивление:

```
A_big → (A₁, A₂, ..., Aₙ) где cost(Aᵢ) < threshold
```

## Стратегии работы с гомеостазом

### 1. Микро-привычки

```
Вместо: "Заниматься спортом 1 час в день"
Делать: "10 отжиманий утром"
```

```
adaptation_cost("10 отжиманий") << adaptation_cost("1 час спорта")
```

### 2. Триггеры и привязка

```
Новая процедура A_new привязывается к существующей A_routine:

trigger(A_routine) → execute(A_new)
```

**Пример:**

"После утреннего кофе (триггер) → 5 минут чтения"

### 3. Постепенное увеличение

```
Week 1: A (10 минут)
Week 2: A (15 минут)
Week 3: A (20 минут)
...
```

Система адаптируется постепенно, без резкого скачка стоимости.

### 4. Восстановление обязательно

```
∀ период активности ∃ период восстановления:
  recovery_time ≥ activity_time × recovery_coefficient
```

Без восстановления система перегружается и включает защиту.

## Формальная граница

**Теорема о пределе процедур:**

```
∃ N_max: 
  если количество активных процедур > N_max
  то система деградирует
```

**Доказательство:**
Каждая процедура имеет стоимость > 0.
Общая энергия ограничена.

```
Σ cost(Pᵢ) ≤ total_energy
```

При превышении порога:

```
Σ cost(Pᵢ) > total_energy 
⟹ Energy(S) < 0 
⟹ система не может функционировать
```
∎

## Вывод

**Гомеостаз — не враг, а защитный механизм.**

Система «Шанс» должна:
1. Учитывать ограниченность энергии
2. Внедрять процедуры последовательно
3. Уважать потребность в восстановлении
4. Минимизировать сопротивление через малые шаги

```
sustainable_change = respect(homeostasis) + gradual_adaptation
```

Быстрые изменения → сильное сопротивление → откат
Медленные изменения → слабое сопротивление → стабильный рост

Ссылки:
- `docs/core/math.md` — формализация процедур и MES
- `docs/problems/plan-correctness-problem.md` — почему планы требуют корректировки

