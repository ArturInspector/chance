# Проблема корректности плана (Plan Correctness Problem)

## Формулировка

**Основное утверждение:**

Любой план не может быть предсказан изначально полностью. Корректность плана определяется только post-factum.

```
∀ P (план), ∀ G (цель):
  correct(P, G) можно установить только после execute(P)
```

## Проблема априорной непроверяемости

### 1. Гипотеза плана
При построении плана P для достижения цели G, мы формулируем гипотезу:

```
hypothesis(P, G): execute(P) ⟹ achieve(G)
```

Но эта гипотеза **непроверяема до выполнения**.

### 2. Скрытые условия

План строится на явных preconditions:

```
P = (A₁, A₂, ..., Aₙ)
preconditions(P) = {C₁, C₂, ..., Cₖ}
```

Но существуют скрытые условия:

```
hidden_conditions(P) = {H₁, H₂, ..., Hₘ}
```
которые обнаруживаются только при выполнении. Или хуже того - **ПОСЛЕ** выполнения. !

**Пример:**
Цель: увеличить мышечную массу на 5%
План:
- A₁: тренировки 3 раза в неделю
- A₂: употребление 2г белка на кг веса
- A₃: сон 8 часов

Явные preconditions: время, доступ к залу, бюджет на питание

Скрытые conditions (обнаруженные post-factum):
- H₁: уровень тестостерона в норме
- H₂: отсутствие хронического стресса
- H₃: правильная техника выполнения упражнений
- H₄: достаточное потребление микроэлементов

### 3. Неполнота знания

```
knowledge_at_start(P) ⊂ knowledge_required(P)
```

Разрыв знаний:

```
gap(P) = knowledge_required(P) \ knowledge_at_start(P)
```

Этот разрыв **неустраним априори**.

## Итеративная верификация

### 1. Цикл планирования

```
function iterative_planning(G):
  P = initial_plan(G)
  
  loop:
    result = execute(P)
    
    if achieve(G):
      return success(P)
    
    // Анализ провала
    missing = analyze_gap(P, result, G)
    
    // Обновление плана
    P' = update_plan(P, missing)
    
    if not feasible(P'):
      return failure("Цель недостижима с текущими ресурсами")
    
    P = P'
```

### 2. Метрика корректности

Корректность плана определяется только результатом:

```
correctness(P, G) = {
  1.0  if achieve(G) after execute(P)
  0.0  if not achieve(G)
  ∈ (0, 1)  if partial achievement
}
```

**До выполнения:**
```
expected_correctness(P, G) = belief(agent, P, G)
```

Это субъективная оценка, не корректность.

### 3. Калибровка убеждений
```
function calibrate_beliefs(history):
  for (P, G, result) in history:
    expected = belief(agent, P, G)
    actual = correctness(P, G)
    
    error = |expected - actual|
    
    update_belief_model(error)
```

Со временем агент учится лучше предсказывать, но полной достоверности нет.

## Формальная граница
**Теорема о неполноте планирования:**

```
∄ алгоритм plan(G): 
  ∀ G: correctness(plan(G), G) = 1.0 (априори)
```

**Доказательство:**

Предположим существует такой алгоритм `plan(G)`.

Рассмотрим цель G: "увеличить мышечную массу на 5%"
Для гарантии correctness = 1.0, план должен учесть:
- Все биохимические процессы организма
- Все факторы среды
- Все будущие события

Это требует:
1. Полного знания состояния организма (невозможно, см. Observer Problem)
2. Предсказания будущего (невозможно из-за хаотичности систем)

Следовательно, алгоритм не существует.
∎

## Практические следствия

### 1. Принятие неопределённости
План P — это **гипотеза**, а не **гарантия**.

```
P = hypothesis(G, current_knowledge)
```

### 2. Петля обратной связи обязательна
```
execute(P) → measure(result) → update(P) → execute(P')
```
Без обратной связи система слепа к скрытым условиям.

### 3. Минимизация цикла обратной связи
Чем быстрее проверка гипотезы, тем быстрее обновление плана:

```
optimal_cycle_time = min(time(execute(P)) + time(measure(result)))
```

Отсюда: декомпозиция на мелкие шаги с частой проверкой лучше, чем один большой план.

## Стратегия работы с проблемой

### 1. Разделение на фазы

```
Phase 1: Построение начального плана (based on current knowledge)
Phase 2: Выполнение минимального шага
Phase 3: Измерение результата
Phase 4: Обновление плана (если нужно)
Phase 5: Повторить
```

### 2. Явное указание предположений

```
Plan P:
  Assumptions:
    - A₁: тестостерон в норме
    - A₂: нет хронических заболеваний
    - A₃: техника выполнения правильная
  
  Actions: [...]
  
  Verification:
    - После 2 недель: проверить массу
    - Если не растёт → проверить assumptions
```

### 3. Встроенные точки проверки

```
P = (A₁, CHECK₁, A₂, CHECK₂, ..., Aₙ)
```

где `CHECKᵢ` — контрольная точка для верификации промежуточного результата.

## Вывод

**Корректность плана непознаваема априори.**

```
wisdom ≠ "знать правильный план"
wisdom = "быстро обновлять неправильный план"
```


Ссылки:
- `docs/problems/observer-problem.md` — почему измерение субъективно
- `docs/core/math.md` — алгоритмы декомпозиции и планирования

