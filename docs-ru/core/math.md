## Математическая формализация проекта «Шанс»
### Процедурная декомпозиция жизни

---

## 0. Философский фундамент

**Ключевой принцип:**

Система не спрашивает «зачем» и не предсказывает «что будет».
Система спрашивает: **«что именно ты делаешь руками»** и к чему это приведет.

Всё сводится к пяти элементам:
1. **Действие** — физическое/когнитивное действие, исполняемое агентом
2. **условие** — preconditions для выполнения действия
3. **Длительность** — время выполнения
4. **повторяемость** — частота/регулярность
5. **Факт выполнения** — бинарный исход (сделал/не сделал)

**Процедурность операций Lisp:**
Lisp оперирует композицией малых процедур, а не одной огромной.
Человек — та же процедурная машина, но без явной спецификации процедур.

**Цель проекта:**
Формализовать процедуры жизни, декомпозировать до атомарных действий, выявить разрывы.

---

## 1. Формальные определения. Вводная.

### 1.1 Атомарное действие

**Действие A** называется **атомарным**, если:

```
∀ A: atomic(A) ⟺ 
  (1) A выполняется за один сеанс без прерываний
  (2) A имеет ясный критерий завершения
  (3) A не требует декомпозиции для понимания
  (4) A выполняется физически или когнитивно агентом
```

**Примеры:**
- Атомарное: «Написать функцию def hello()», «Пробежать 1км», «Приготовить яйца на сковородке методом обжарки»
- Не атомарное: «Выучить Python» (требует декомпозиции), «Стать программистом» (нет критерия завершения)

### 1.2 Процедура
**Процедура P** — упорядоченная последовательность действий:

```
P = (A₁, A₂, ..., Aₙ)
```

где каждое Aᵢ — атомарное или композитное действие.

**Процедура имеет:**
- **Input**: preconditions (что нужно до начала)
- **Output**: postconditions (что получим после)
- **Contract**: P корректна, если при выполнении всех Aᵢ postconditions гарантированы

### 1.3 Цель

**Цель G** — желаемое состояние с критерием достижения.
Цель **оптимальна**, если:
```
∃ P: execute(P) ⟹ achieve(G)  ∧  measurable(G)  ∧  controllable(P)
```
где:
- **measurable(G)**: можно объективно проверить достижение (смотрите docs/dependency-measure.md)
- **controllable(P)**: агент контролирует выполнение процедуры

**Примеры:**
| Цель | Оптимальна? | Почему |
|------|-------------|--------|
| «Учить Python» | ❌ | Нет критерия завершения, не измеряема |
| «Разучить 3 паттерна функций для собеседования» | ✅ | Измеряема, есть критерий, контролируема |
| «Получить работу в Google» | ❌ | Не контролируема (зависит от внешних агентов) |
| «Подготовить резюме и пройти 10 собеседований» | ✅ | Измеряема, контролируема |

---

## 2. Декомпозиция цели в процедуру

### 2.1 Алгоритм декомпозиции

Дана цель G. Строим процедуру P:

```
function decompose(G):
  if atomic(G):
    return [G]  // G уже атомарна
  
  if not measurable(G):
    return error("Цель не измерима, переформулируй")
  
  steps = []
  current_state = initial_state()
  
  while not achieved(G, current_state):
    // Найти следующий атомарный шаг
    A = find_next_atomic_step(G, current_state)
    
    if A == null:
      return error("Невозможно декомпозировать, цель недостижима")
    
    steps.append(A)
    current_state = apply(A, current_state)
  
  return steps
```

### 2.2 Граф зависимостей
Цель G разбивается на подцели и действия:

```
G = {G₁, G₂, ..., Gₖ}  // подцели - точки пересечений (см. paratistic-goals)
Gᵢ = {A₁, A₂, ..., Aₘ}  // атомарные действия
```

**Граф зависимостей** — направленный ациклический граф (DAG):

```
Graph = (V, E)

V = Goals ∪ Actions  // вершины: цели и действия
E ⊆ V × V           // рёбра: зависимости

(u, v) ∈ E  ⟺  v зависит от u (u должно быть выполнено до v)
```

**Пример:**

Цель: «Запустить проект Chance»

```
Запустить проект
  ├─ Формализовать концепцию (done)
  ├─ Выбрать стек (done)
  ├─ Создать лендинг
```

### 2.3 Критерии хорошей декомпозиции

Декомпозиция **корректна**, если:

```
∀ Gᵢ ∈ decompose(G): 
  (1) atomic(Gᵢ) ∨ decomposable(Gᵢ)  // либо атомарна, либо декомпозируема дальше
  (2) measurable(Gᵢ)                  // измерима
  (3) ∀ preconditions satisfied       // условия выполнимы
  (4) acyclic(dependency_graph)       // граф ациклический
```

---

## 3. Формализация пяти элементов

### 3.1 Действие (Action)

```
Action A = {
  id: string,
  description: string,
  type: 'physical' | 'cognitive',
  atomic: boolean
}
```

**Физическое действие**: «написать код руками», «пробежать», «приготовить еду»

**Когнитивное действие**: «прочитать главу», «решить задачу», «спроектировать архитектуру»

### 3.2 Условие (Condition)

```
Condition C = {
  type: 'precondition' | 'postcondition',
  description: string,
  verifiable: boolean,
  controllable: boolean
}
```

**Precondition** — что нужно ДО выполнения действия:
- «Иметь компьютер», «Иметь доступ к интернету», «Знать синтаксис Python»

**Postcondition** — что получим ПОСЛЕ:
- «Функция написана», «Тесты проходят», «Деплой выполнен»

**Controllable** — может ли агент обеспечить условие сам:
- Controllable: «выделить 1 час времени», «открыть редактор»
- Uncontrollable: «получить одобрение от другого человека», «хорошая погода»



### 3.3 Длительность (Duration)
```
Duration = {
  estimated: number,  // оценочное время в минутах
  actual: number,     // фактическое время
  unit: 'minutes' | 'hours' | 'days'
}
```

Оценка точности:

```
accuracy = |estimated - actual| / actual
```

Система со временем калибрует оценки на основе истории.

### 3.4 Повторяемость (Repeatability)
```
Repeatability = {
  frequency: number,       // как часто
  period: 'daily' | 'weekly' | 'monthly' | 'once',
  regularity: [0, 1]      // 0 = никогда не повторяется, 1 = всегда в срок
}
```

**Регулярность** вычисляется как:

```
regularity = (выполнено в срок) / (запланировано)
```

### 3.5 Факт выполнения (Completion)

```
Completion = {
  status: 'done' | 'not_done' | 'partial' | 'blocked',
  timestamp: Date,
  reason_if_not: string
}
```

**Бинарный исход**: сделал / не сделал — объективно проверяемый факт.

---

## 4. Детекция разрывов процедур

### 4.1 Разрыв процедуры

**Разрыв** (breakpoint) — систематический провал выполнения действия.

```
Breakpoint B = {
  action: A,
  failure_count: number,
  reasons: [string],
  pattern: 'time' | 'energy' | 'clarity' | 'external'
}
```

### 4.2 Классификация разрывов

**1. Временной разрыв (Time)**

```
∀ A: time_breakpoint(A) ⟺ duration(A) > available_time
```

Решение: декомпозировать A на более мелкие шаги или выделить больше времени.

**2. Энергетический разрыв (Energy)**

```
∀ A: energy_breakpoint(A) ⟺ required_energy(A) > current_energy
```

Решение: упростить A или восстановить энергию (сон, отдых).

**3. Разрыв ясности (Clarity)**

```
∀ A: clarity_breakpoint(A) ⟺ not(atomic(A)) ∨ not(measurable(A))
```

Решение: декомпозировать дальше до атомарности.

**4. Внешний разрыв (External)**

```
∀ A: external_breakpoint(A) ⟺ ∃ precondition C: not(controllable(C))
```

Решение: построить fallback-процедуру или принять риск.

### 4.3 Алгоритм детекции

```
function detect_breakpoints(history):
  breakpoints = []
  
  for action A in history:
    failures = [entry for entry in history if entry.action == A and entry.status != 'done']
    
    if len(failures) >= threshold:
      reasons = aggregate_reasons(failures)
      pattern = classify_pattern(reasons)
      
      breakpoints.append({
        action: A,
        failure_count: len(failures),
        reasons: reasons,
        pattern: pattern
      })
  
  return breakpoints
```

---

## 5. Минимальный исполнимый шаг (MES)

### 5.1 Определение

**Минимальный исполнимый шаг (MES)** — атомарное действие, которое:

```
∀ A: is_MES(A) ⟺ 
  (1) atomic(A)
  (2) all preconditions satisfied
  (3) controllable(A)
  (4) estimated_duration(A) ≤ threshold  (например, 60 мин)
  (5) highest_priority(A) among all candidates
```

### 5.2 Алгоритм выбора MES

```
function find_MES(graph, current_state):
  // Шаг 1: найти все доступные действия
  available = [A for A in graph.actions if preconditions_satisfied(A, current_state)]
  
  // Шаг 2: отфильтровать контролируемые и атомарные
  executable = [A for A in available if atomic(A) and controllable(A)]
  
  // Шаг 3: ранжировать по приоритету и длительности
  ranked = sort(executable, key=lambda A: (priority(A), duration(A)))
  
  // Шаг 4: выбрать первый
  return ranked[0] if len(ranked) > 0 else null
```

### 5.3 Свойства MES

**Теорема**: Если каждый день выполнять MES, то:

```
lim(t→∞) progress(G, t) → 1
```

при условии, что граф G достижим и ациклический.

**Доказательство** (sketch):

Каждый выполненный MES уменьшает число оставшихся действий на 1.
Граф конечен и ациклический → процесс терминирует.
При регулярном выполнении → конечное время до достижения G.
Стоит учесть condition - если paratistic goals исполнен и все убеждения верны.

Observer Problem
∎

---

## 6. Оптимальность целей

### 6.1 Критерий оптимальности

Цель G **оптимальна**, если:

```
optimal(G) ⟺ 
  (1) measurable(G)          // измерима
  (2) ∃ P: controllable(P)   // процедура контролируема
  (3) finite(P)              // процедура конечна
  (4) value(G) > cost(P)     // ценность > издержки
```

### 6.2 Трансформация неоптимальных целей

**Неоптимальная**: «Учить Python»

Проблемы:
- Не измерима (когда «выучил»?)
- Нет критерия завершения
- Процедура не определена

**Трансформация**:

```
Учить Python 
  → Зачем? → Для собеседований
  → Что конкретно? → Разучить 3 паттерна функций
  → Как измерить? → Решить 10 задач на каждый паттерн
  → Сколько времени? → 2 недели, 1 час в день
```

**Оптимальная**: «Разучить 3 паттерна функций (map, filter, reduce) + решить по 10 задач на каждый за 2 недели»

### 6.3 Алгоритм оптимизации

```
function optimize_goal(G):
  if optimal(G):
    return G
  
  // Шаг 1: уточнить критерий
  if not measurable(G):
    G = add_measurable_criterion(G)
  
  // Шаг 2: декомпозировать до контролируемых шагов
  if not controllable(procedure(G)):
    G = extract_controllable_part(G)
  
  // Шаг 3: ограничить горизонт
  if not finite(procedure(G)):
    G = set_time_bound(G)
  
  return G
```

---

## 7. Процедуры жизни: хорошие и плохие

### 7.1 Структура процедуры

Любая активность — процедура. Даже «залипание в TikTok».

```
Процедура: Залипание в TikTok

Preconditions:
  - Иметь телефон
  - Иметь доступ к интернету
  - Приложение установлено

Шаги:
  1. Взять телефон
  2. Разблокировать
  3. Открыть TikTok
  4. Скроллить
  5. [повторять шаг 4 до прерывания]

Postconditions:
  - Время потрачено: 30–120 мин
  - Дофамин: кратковременный
  - Прогресс к целям: 0
```

### 7.2 Метрика полезности процедуры

```
utility(P) = value(postconditions(P)) - cost(P)
```

где:
- **value** — ценность результата (движение к целям, удовольствие, здоровье)
- **cost** — издержки (время, энергия, отвлечение от других целей)

**TikTok**:
```
utility = 2 (кратковременное удовольствие) - 60 (время) - 10 (отвлечение) = -68
```

**Разучивание функций Python**:
```
utility = 50 (движение к цели) - 60 (время) = -10
```

Но с учётом долгосрочной ценности:
```
utility_long_term = 50 + 100 (получение работы) - 60 = +90
```

### 7.3 Детекция паразитных процедур

**Паразитная процедура** — процедура с отрицательной долгосрочной полезностью, которая выполняется регулярно.

```
parasitic(P) ⟺ 
  (1) utility_long_term(P) < 0
  (2) frequency(P) > threshold
  (3) not(necessary(P))  // не является необходимой (еда, сон — необходимы)
```

**Алгоритм детекции**:

```
function detect_parasitic_procedures(log):
  procedures = aggregate_by_pattern(log)
  
  parasitic = []
  for P in procedures:
    if utility_long_term(P) < 0 and frequency(P) > 3/week:
      parasitic.append(P)
  
  return parasitic
```

---

## 8. Теория композиции процедур

### 8.1 Композиция

Процедуры можно композировать:

```
compose(P₁, P₂) = P₃

где postconditions(P₁) ⊆ preconditions(P₂)
```

**Пример**:

```
P₁: Написать функцию
  → postcondition: функция существует

P₂: Написать тесты
  → precondition: функция существует
  → postcondition: функция протестирована

compose(P₁, P₂) = P₃: Написать и протестировать функцию
```

### 8.2 Параллельная композиция

Процедуры независимы, если не делят ресурсы:

```
parallel(P₁, P₂) ⟺ 
  resources(P₁) ∩ resources(P₂) = ∅
```

**Пример**:
- P₁: Учить Python (ресурс: время утром, когнитивная энергия)
- P₂: Бегать (ресурс: время вечером, физическая энергия)

Независимы → можно выполнять параллельно.

### 8.3 Рекурсивная композиция

Процедура может вызывать саму себя (рекурсия).

```
P_recursive(n) = {
  if n == 0: return base_case
  else: return step + P_recursive(n-1)
}
```

**Опасность**: бесконечная рекурсия → нужно условие терминации.

---

## 9. Математическая модель выполнения

### 9.1 Состояние системы

```
State S = (G_set, A_completed, resources, time)
```

**ВАЖНО!**

где:
- **G_set** — множество текущих целей
- **A_completed** — выполненные действия
- **resources** — доступные ресурсы (время, энергия, деньги)
- **time** — текущее время

### 9.2 Переход состояния

```
transition(S, A) → S'

где:
  S' = (G_set', A_completed ∪ {A}, resources - cost(A), time + duration(A))
```

### 9.3 Достижение цели

Цель G достигнута в состоянии S, если:

```
achieved(G, S) ⟺ postconditions(G) ⊆ facts(S)
```

### 9.4 Функция ценности

```
V(S) = Σ value(G) for G in achieved_goals(S)
```

Задача оптимизации:

```
maximize V(S_final)
subject to:
  S_0 → S_1 → ... → S_final
  time(S_final) ≤ T
  resources(S_i) ≥ 0  ∀ i
```

---

## 10. Практические алгоритмы

### 10.1 Ежедневный планировщик

```
function daily_planner(goals, current_state):
  // Шаг 1: найти MES для каждой цели
  MES_candidates = [find_MES(G, current_state) for G in goals]
  
  // Шаг 2: оценить доступное время и энергию
  available_time = estimate_available_time()
  available_energy = estimate_energy()
  
  // Шаг 3: выбрать MES, которые умещаются в ресурсы
  plan = []
  for MES in MES_candidates:
    if duration(MES) <= available_time and required_energy(MES) <= available_energy:
      plan.append(MES)
      available_time -= duration(MES)
      available_energy -= required_energy(MES)
  
  return plan
```

### 10.2 Детектор застревания

Если одна и та же цель не продвигается N дней подряд:

```
function detect_stuck(goal_log):
  for G in goals:
    progress_history = [entry for entry in goal_log if entry.goal == G]
    
    if len(progress_history) > N and all(entry.status != 'done' for entry in progress_history[-N:]):
      return alert("Цель застряла: " + G.description)
```

### 10.3 Автоматическая декомпозиция (с помощью LLM)

```
function auto_decompose(G, llm):
  if atomic(G):
    return [G]
  
  prompt = f"""
  Цель: {G.description}
  Декомпозируй на атомарные шаги. Каждый шаг должен:
  - Быть выполним за один сеанс
  - Иметь ясный критерий завершения
  - Быть описан в терминах конкретных действий
  """
  
  steps = llm.generate(prompt)
  
  return steps
```

---

## 11. Границы применимости

### 11.1 Что работает

**Процедурный подход применим к:**
- Навыкам (программирование, музыка, спорт)
- Проектам (создание продукта, написание книги)
- Привычкам (сон, питание, тренировки)
- Рутинам (работа, учёба)

**Условия применимости:**
```
applicable(G) ⟺ 
  (1) measurable(G)
  (2) decomposable(G)
  (3) finite_horizon(G)
```

### 11.2 Что не работает

**Процедурный подход НЕ применим к:**
- Целям без критериев («быть счастливым»)
- Сильно зависящим от внешних агентов («получить повышение»)
- Эмерджентным свойствам («найти смысл жизни»)

**Но:** даже в этих случаях можно выделить контролируемую часть и работать с ней.

---

## 12. Главная теорема

**Теорема о процедурной достижимости:**

Пусть G — цель, P — процедура, S₀ — начальное состояние.

Если:
1. G измерима и конечна
2. P корректно декомпозирована до атомарных шагов
3. Все preconditions контролируемы агентом
4. Граф зависимостей ациклический

То:

```
∃ T: execute(P, S₀, T) ⟹ achieved(G, S_T)
```

**Доказательство**:

По условиям (1)-(4):
- G имеет конечное число шагов (из конечности и декомпозиции)
- Каждый шаг выполним (из контролируемости preconditions)
- Нет циклов (из ацикличности)

Следовательно, последовательное выполнение всех шагов терминирует и приводит к G.

∎

---

## 13. Заключение

**Что можем:**
- Формализовать любую цель как граф процедур
- Декомпозировать до атомарных исполнимых шагов
- Детектировать разрывы и паразитные процедуры
- Выбирать минимальный исполнимый шаг каждый день
- Измерять прогресс объективно

**Чего не можем:**
- Устранить неконтролируемые зависимости
- Гарантировать результат при участии внешних агентов
- Формализовать цели без критериев завершения

**Главный вывод:**

Человек страдает не от неопределённости исходов,
а от отсутствия процедур, которые можно выполнить без веры в результат.

Проект «Шанс» даёт эти процедуры.

---

## Список обозначений

- **A** — действие (Action)
- **P** — процедура (Procedure)
- **G** — цель (Goal)
- **S** — состояние системы (State)
- **MES** — минимальный исполнимый шаг (Minimal Executable Step)
- **DAG** — направленный ациклический граф (Directed Acyclic Graph)
- **atomic(A)** — предикат атомарности действия
- **measurable(G)** — предикат измеримости цели
- **controllable(P)** — предикат контролируемости процедуры
