## Измерение зависимостей (Dependency Measure)
### Как мир реагирует на наши процедуры

---

## 0. Суть проблемы

**Ключевой вопрос:**

Мы выполняем процедуры. Но как понять, работают ли они?

**Dependency injection в жизни:**

В программировании: мы инжектируем зависимость, система реагирует предсказуемо.

В жизни: мы выполняем действия (инжектируем свои процедуры в мир), мир даёт feedback.

**Проблема:**

Feedback может быть:
- Отложенным (результат через месяцы)
- Зашумлённым (много факторов влияют)
- Неоднозначным (непонятно, что сработало, а что нет)

**Цель документа:**

Формализовать, как измерять эффективность процедур через реакцию мира и когда менять стратегию.

---

## 1. Формальная модель взаимодействия

### 1.1 Агент, процедура, мир

```
Agent → execute(Procedure) → World → Feedback → Agent
```

**Элементы:**

- **Agent** — человек/система, выполняющая процедуры
- **Procedure P** — последовательность действий
- **World W** — внешняя реальность (люди, рынок, природа)
- **Feedback F** — отклик мира на процедуру

### 1.2 Состояние мира

```
World_state = (external_factors, agent_influence)
```

где:
- **external_factors** — то, что агент не контролирует (погода, экономика, другие люди)
- **agent_influence** — изменения, вызванные агентом

### 1.3 Функция отклика

Мир реагирует на процедуру с задержкой и шумом:

```
F(t) = response(P, t - Δt) + noise(t)
```

где:
- **Δt** — задержка отклика
- **noise(t)** — случайные факторы

**Проблема:**

Мы не знаем истинную функцию response заранее. Можем только наблюдать F(t) и инферировать.

---

## 2. Типы зависимостей

### 2.1 Классификация

**1. Прямая зависимость (Direct)**

```
P → F

Выполнение P напрямую вызывает F
```

**Примеры:**
- Написал код → код работает
- Отправил резюме → получил ответ (или нет)
- Опубликовал статью → получил просмотры

**Свойства:**
- Короткая задержка (минуты/дни)
- Высокая предсказуемость
- Измеримый результат

---

**2. Косвенная зависимость (Indirect)**

```
P → intermediate_state → F

Выполнение P создаёт промежуточное состояние, которое потом влияет на F
```

**Примеры:**
- Тренировки → улучшение физ. формы → лучшее самочувствие
- Обучение → навык → трудоустройство
- Нетворкинг → связи → возможности

**Свойства:**
- Средняя задержка (недели/месяцы)
- Средняя предсказуемость
- Нужны промежуточные метрики

---

**3. Стохастическая зависимость (Stochastic)**

```
P → увеличивает вероятность F, но не гарантирует

P(F | P) > P(F | ¬P)
```

**Примеры:**
- Подготовка к собеседованию → вероятность оффера выше, но не гарантия
- Маркетинг → вероятность продаж выше
- Знакомства → вероятность отношений выше

**Свойства:**
- Высокая неопределённость
- Требуется много итераций для оценки
- Зависит от внешних факторов

---

**4. Отсутствие зависимости (No dependency)**

```
P ⊥ F

Выполнение P не влияет на F
```

**Примеры:**
- Медитация → количество денег (напрямую не влияет, косвенно через продуктивность — может)
- Чтение гороскопа → реальные события

**Свойства:**
- Процедура бесполезна для достижения F
- Трата ресурсов впустую

---

## 3. Измерение feedback

### 3.1 Метрики отклика

Для процедуры P и цели G определим:

**1. Время до первого feedback (Time to First Feedback, TTFF)**

```
TTFF(P) = min { t : |F(t)| > noise_threshold }
```

Чем меньше TTFF, тем быстрее можем оценить эффективность P.

**Примеры:**
- Код: TTFF = минуты (запустил → работает/нет)
- Продукт: TTFF = дни/недели (запустил → первые пользователи)
- Здоровье: TTFF = недели/месяцы (начал тренировки → улучшение)

---

**2. Сила отклика (Response Strength)**

```
strength(F) = |F_observed - F_baseline| / σ_noise
```

Отношение сигнала к шуму. Чем выше, тем яснее, что P работает.

---

**3. Направление отклика (Response Direction)**

```
direction(F) = sign(F_observed - F_expected)

+1: лучше ожидаемого
 0: как ожидалось
-1: хуже ожидаемого
```

---

**4. Стабильность отклика (Response Stability)**

```
stability(F) = 1 - Var(F) / E[F]²
```

Чем стабильнее, тем предсказуемее процедура.

---

### 3.2 Алгоритм измерения

```
function measure_response(P, G, duration):
  baseline = measure_baseline(G)  // до выполнения P
  
  execute(P, duration)
  
  feedback = measure_outcome(G)  // после выполнения P
  
  TTFF = time_to_first_signal(feedback)
  strength = (feedback - baseline) / noise_std
  direction = sign(feedback - expected)
  
  return {
    TTFF: TTFF,
    strength: strength,
    direction: direction,
    signal_to_noise: strength
  }
```

---

## 4. Детекция коренных ошибок

### 4.1 Проблема: построили сервис, но он не работает

**Сценарий:**

1. Цель: запустить SaaS сервис
2. Процедура: 15 дней разработки + маркетинг
3. Факт: запустили, но продаж нет

**Вопросы:**
- Где коренная ошибка?
- В продукте? В маркетинге? В целевой аудитории?
- Когда нужно менять процедуры полностью?

### 4.2 Типы коренных ошибок

**1. Ошибка в цели (Goal Error)**

```
goal_error ⟺ G не соответствует реальной потребности рынка
```

**Пример**: Сделали продукт, который никому не нужен.

**Индикатор**: Нет интереса даже при бесплатном доступе.

**Решение**: Pivot или отмена проекта.

---

**2. Ошибка в процедуре (Procedure Error)**

```
procedure_error ⟺ P не ведёт к G, хотя G корректна
```

**Пример**: Продукт нужен, но маркетинг неэффективен.

**Индикатор**: Есть интерес, но конверсия низкая.

**Решение**: Изменить процедуру (другой канал маркетинга, другое позиционирование).

---

**3. Ошибка в декомпозиции (Decomposition Error)**

```
decomposition_error ⟺ P содержит неверные шаги или пропуски
```

**Пример**: Продукт сделан, но не протестирован → багов много → пользователи уходят.

**Индикатор**: Высокий churn, негативные отзывы.

**Решение**: Дополнить процедуру недостающими шагами (тестирование, UX-исследование).

---

**4. Ошибка в предпосылках (Assumption Error)**

```
assumption_error ⟺ preconditions(P) не выполнены
```

**Пример**: Предположили, что аудитория платёжеспособна, но это не так.

**Индикатор**: Интерес есть, но никто не платит.

**Решение**: Пересмотреть предпосылки и целевую аудиторию.

---

**5. Ошибка в тайминге (Timing Error)**

```
timing_error ⟺ P выполнена слишком рано или слишком поздно
```

**Пример**: Запустили продукт до готовности рынка или после насыщения.

**Индикатор**: «Слишком рано» или «слишком поздно».

**Решение**: Пересмотреть тайминг или pivot.

---

### 4.3 Алгоритм диагностики

```
function diagnose_root_cause(P, G, feedback):
  if no_interest_at_all(feedback):
    return "Goal Error: Цель не соответствует реальной потребности"
  
  if interest_but_no_conversion(feedback):
    if product_quality_low(feedback):
      return "Decomposition Error: Процедура неполная (нет качества)"
    else:
      return "Procedure Error: Маркетинг/позиционирование неэффективны"
  
  if high_churn(feedback):
    return "Decomposition Error: Процедура пропускает важные шаги (UX, поддержка)"
  
  if interest_but_no_payment(feedback):
    return "Assumption Error: Аудитория не платёжеспособна или цена неверна"
  
  if early_or_late_market(feedback):
    return "Timing Error: Неверный тайминг запуска"
  
  return "Unknown: Нужно больше данных"
```

---

## 5. Когда менять процедуры

### 5.1 Критерий смены стратегии

**Правило:**

Менять процедуру P, если:

```
(1) feedback(P) < threshold  после достаточного числа итераций
(2) ∃ альтернативная P': expected_feedback(P') > feedback(P)
(3) cost(pivot) < cost(продолжать P)
```

### 5.2 Время оценки (Evaluation Window)

**Короткий feedback (<7 дней):**
- Быстрая оценка возможна
- Pivot после 2-3 неудачных итераций

**Средний feedback (7-30 дней):**
- Нужно 1-2 месяца на оценку
- Pivot после 3-5 неудачных итераций

**Длинный feedback (>30 дней):**
- Нужно 3-6 месяцев на оценку
- Pivot осторожно, только при ясных индикаторах провала

### 5.3 Индикаторы для pivot

```
function should_pivot(P, G, history):
  iterations = len(history)
  success_rate = count(success) / iterations
  
  if iterations < min_iterations:
    return "Недостаточно данных, продолжай"
  
  if success_rate < threshold:
    return "Pivot: процедура неэффективна"
  
  if trend(feedback) < 0:
    return "Pivot: динамика ухудшается"
  
  if cost_accumulated > budget:
    return "Stop: бюджет исчерпан"
  
  return "Continue: процедура работает"
```

---

## 6. Измерение через A/B эксперименты

### 6.1 Подход

Если неясно, какая процедура лучше:

```
Test: P₁ vs P₂

Выполнить обе процедуры параллельно (если возможно) или последовательно.
Измерить feedback для каждой.
Выбрать лучшую.
```

### 6.2 Пример: маркетинг сервиса

**Гипотеза**: Неясно, какой канал эффективнее.

**Эксперимент:**
- P₁: Контент-маркетинг (блог, SEO)
- P₂: Платная реклама (Google Ads)

**Метрика**: CAC (Customer Acquisition Cost)

**Результат:**
```
CAC(P₁) = $50, конверсия 2%
CAC(P₂) = $100, конверсия 5%
```

**Вывод**: P₂ дороже, но конверсия выше. Если LTV > $100, то P₂ выгоднее.

### 6.3 Статистическая значимость

```
function is_significant(feedback_A, feedback_B):
  p_value = statistical_test(feedback_A, feedback_B)
  
  if p_value < 0.05:
    return "Разница значима"
  else:
    return "Разница случайна, нужно больше данных"
```

---

## 7. Dependency graph в реальности

### 7.1 Построение графа

Цель G декомпозируется на процедуры:

```
G
├─ P₁ → F₁ (прямая зависимость, TTFF=3 дня)
├─ P₂ → intermediate → F₂ (косвенная, TTFF=30 дней)
└─ P₃ → ? (стохастическая, неясно)
```

### 7.2 Измерение каждого узла

Для каждой процедуры Pᵢ:

```
measure(Pᵢ) = {
  TTFF: время до первого feedback,
  strength: сила отклика,
  direction: направление (+ или -),
  confidence: уверенность в измерении
}
```

### 7.3 Приоритизация по feedback

Сначала работаем над процедурами с быстрым и сильным feedback:

```
priority(Pᵢ) = strength(Fᵢ) / TTFF(Pᵢ)
```

Чем выше priority, тем раньше узнаем, работает ли процедура.

---

## 8. Обратная связь: типы и скорость

### 8.1 Классификация по скорости

| Тип feedback | TTFF | Примеры | Стратегия |
|--------------|------|---------|-----------|
| Мгновенный | <1 час | Код работает, UI отклик | Быстрая итерация |
| Быстрый | 1-7 дней | Первые пользователи, лиды | Еженедельная оценка |
| Средний | 1-4 недели | Конверсия, retention | Месячная оценка |
| Медленный | 1-6 месяцев | Revenue, product-market fit | Квартальная оценка |
| Очень медленный | >6 месяцев | Репутация, долгосрочный рост | Годовая оценка |

### 8.2 Стратегия работы с медленным feedback

**Проблема**: Если TTFF = 6 месяцев, нельзя ждать полгода, чтобы понять, работает ли процедура.

**Решение**: Найти **leading indicators** (опережающие индикаторы).

**Пример:**

Цель: Достичь $10K MRR (медленный feedback, ~6 месяцев)

Leading indicators (быстрый feedback):
- Неделя 1: Трафик на сайт
- Неделя 2: Sign-ups
- Неделя 3: Активация
- Неделя 4: Первые платежи

Если leading indicators слабые → pivot раньше, не ждём 6 месяцев.

---

## 9. Формализация через Bayesian inference

### 9.1 Модель

Мы не знаем истинную эффективность процедуры P.

Используем Байесовский подход:

```
Prior: P(effective(P)) = 0.5  // нейтральная гипотеза

После наблюдения feedback F:

Posterior: P(effective(P) | F) ∝ P(F | effective(P)) · P(effective(P))
```

### 9.2 Обновление belief

```
function update_belief(P, feedback):
  prior = current_belief(P)
  likelihood = compute_likelihood(feedback, P)
  posterior = prior * likelihood / normalization
  
  update_belief(P, posterior)
  
  if posterior > threshold_success:
    return "Процедура работает, продолжай"
  elif posterior < threshold_failure:
    return "Процедура не работает, pivot"
  else:
    return "Неопределённость, нужно больше данных"
```

### 9.3 Пример

```
P: Контент-маркетинг для SaaS

Prior: P(effective) = 0.5

Неделя 1: 100 визитов, 0 sign-ups
  → P(effective | data) = 0.3

Неделя 2: 200 визитов, 2 sign-ups
  → P(effective | data) = 0.4

Неделя 3: 300 визитов, 5 sign-ups
  → P(effective | data) = 0.55

Неделя 4: 400 визитов, 10 sign-ups
  → P(effective | data) = 0.7

Вывод: Процедура начинает работать, продолжаем.
```

---

## 10. Практический алгоритм: Dependency Tracker

### 10.1 Структура

Для каждой цели G ведём трекер зависимостей:

```
DependencyTracker = {
  goal: G,
  procedures: [P₁, P₂, ...],
  measurements: [
    {
      procedure: Pᵢ,
      timestamp: t,
      feedback: F,
      TTFF: Δt,
      strength: s,
      direction: d
    },
    ...
  ]
}
```

### 10.2 Ежедневный/еженедельный чек-ин

```
function weekly_checkin(tracker):
  for P in tracker.procedures:
    feedback = measure_latest_feedback(P)
    
    if feedback.direction < 0:
      alert("Процедура " + P + " даёт негативный результат")
    
    if feedback.strength < noise_threshold:
      alert("Нет сигнала от процедуры " + P + ", пересмотри")
    
    if iterations(P) > max_iterations and success_rate(P) < threshold:
      alert("Процедура " + P + " неэффективна, нужен pivot")
```

### 10.3 Dashboard

Визуализация:

```
Goal: Запустить SaaS сервис

Procedure          | TTFF | Strength | Direction | Status
-------------------|------|----------|-----------|--------
Разработка MVP     | 14d  | High     | +1        | Done
Запуск landing     | 3d   | Medium   | +1        | Done
SEO-оптимизация    | 30d  | Low      | 0         | Wait
Платная реклама    | 7d   | High     | -1        | Pivot needed
Контент-маркетинг  | 14d  | Medium   | +1        | Continue
```

**Вывод:** Платная реклама не работает (негативный результат), нужен pivot.

---

## 11. Теорема о критическом feedback

**Теорема:**

Пусть P — процедура, G — цель, TTFF — время до feedback.

Если:

```
TTFF(P) > T_critical

и

no leading indicators available
```

То:

```
P непригодна для итеративной оптимизации
```

**Интерпретация:**

Если feedback слишком медленный и нет опережающих индикаторов, невозможно быстро итерировать.

Такие процедуры высокорискованны.

**Решение:**

1. Декомпозировать P на шаги с более быстрым feedback
2. Найти leading indicators
3. Запустить эксперимент в меньшем масштабе (MVP)

---

## 12. Примеры измерения зависимостей

### Пример 1: Запуск SaaS

**Цель**: Достичь $10K MRR за 6 месяцев

**Процедуры и зависимости:**

```
P₁: Разработка MVP (2 недели)
  → F₁: Продукт готов (TTFF=14 дней, direct)

P₂: Landing page + запуск (1 неделя)
  → F₂: Первые визиты (TTFF=3 дня, direct)

P₃: Контент-маркетинг (ongoing)
  → F₃: Органический трафик (TTFF=30 дней, indirect)

P₄: Платная реклама (1 неделя тест)
  → F₄: Платные лиды (TTFF=7 дней, direct)

P₅: Конверсия в платящих (ongoing)
  → F₅: Revenue (TTFF=14 дней, stochastic)
```

**Измерение:**

- Неделя 1-2: P₁ → F₁ (продукт готов) ✅
- Неделя 3: P₂ → F₂ (100 визитов, 5 sign-ups) ✅
- Неделя 4: P₄ → F₄ (CAC=$100, конверсия 3%) ⚠️ (дорого)
- Неделя 5-8: P₃ → F₃ (трафик растёт медленно) ⏳ (ждём)
- Неделя 9: P₅ → F₅ (первые $500 MRR) ✅

**Pivot на неделе 4**: Платная реклама слишком дорогая → переключаемся на органику.

---

### Пример 2: Улучшение здоровья

**Цель**: Снизить вес на 10кг за 3 месяца

**Процедуры и зависимости:**

```
P₁: Дефицит калорий (ежедневно)
  → F₁: Потеря веса (TTFF=7 дней, direct)

P₂: Тренировки 3 раза в неделю
  → F₂: Улучшение формы (TTFF=14 дней, indirect)

P₃: Сон 8 часов
  → F₃: Энергия и восстановление (TTFF=3 дня, direct)
```

**Измерение:**

- Неделя 1: P₁ → F₁ (-1кг) ✅
- Неделя 2: P₁ + P₂ → F₁ (-0.5кг, plateau) ⚠️
- Неделя 3: P₁ + P₂ + P₃ → F₁ (-1кг снова) ✅

**Вывод**: P₃ (сон) критичен для прогресса, без него plateau.

---

## 13. Заключение

**Что можем:**
- Формализовать типы зависимостей (прямые, косвенные, стохастические)
- Измерить feedback (TTFF, strength, direction)
- Диагностировать коренные ошибки (цель, процедура, декомпозиция, предпосылки, тайминг)
- Определить, когда менять процедуры (критерии pivot)
- Использовать leading indicators для медленного feedback

**Чего не можем:**
- Предсказать реакцию мира со 100% точностью
- Устранить стохастичность и внешние факторы
- Ускорить feedback, если он объективно медленный

**Главный вывод:**

> Мир — это единственный честный источник обратной связи.  
> Измерение зависимостей позволяет отличить работающие процедуры от неработающих.  
> Быстрый feedback → быстрая итерация → быстрое достижение целей.

---

## Список обозначений

- **P** — процедура (Procedure)
- **G** — цель (Goal)
- **F** — feedback (обратная связь от мира)
- **TTFF** — Time to First Feedback (время до первого отклика)
- **W** — мир (World)
- **direct/indirect/stochastic** — типы зависимостей
- **strength** — сила отклика
- **direction** — направление отклика (+/0/-)
- **leading indicators** — опережающие индикаторы

